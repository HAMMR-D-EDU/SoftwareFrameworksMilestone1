{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let DataService = /*#__PURE__*/(() => {\n  class DataService {\n    constructor() {\n      this.USERS_KEY = 'app:users';\n      this.GROUPS_KEY = 'app:groups';\n      this.CHANNELS_KEY = 'app:channels';\n    }\n    // User management\n    getAllUsers() {\n      return JSON.parse(localStorage.getItem(this.USERS_KEY) || '[]');\n    }\n    getUserById(id) {\n      const users = this.getAllUsers();\n      return users.find(u => u.id === id) || null;\n    }\n    updateUser(user) {\n      const users = this.getAllUsers();\n      const index = users.findIndex(u => u.id === user.id);\n      if (index !== -1) {\n        users[index] = user;\n        localStorage.setItem(this.USERS_KEY, JSON.stringify(users));\n      }\n    }\n    deleteUser(userId) {\n      const users = this.getAllUsers();\n      const groups = this.getAllGroups();\n      const channels = this.getAllChannels();\n      // Remove user from all groups\n      groups.forEach(group => {\n        group.memberUserIds = group.memberUserIds.filter(id => id !== userId);\n        group.adminUserIds = group.adminUserIds.filter(id => id !== userId);\n      });\n      // Remove user from all channels (banned list)\n      channels.forEach(channel => {\n        channel.bannedUserIds = channel.bannedUserIds.filter(id => id !== userId);\n      });\n      // Remove user\n      const updatedUsers = users.filter(u => u.id !== userId);\n      localStorage.setItem(this.USERS_KEY, JSON.stringify(updatedUsers));\n      localStorage.setItem(this.GROUPS_KEY, JSON.stringify(groups));\n      localStorage.setItem(this.CHANNELS_KEY, JSON.stringify(channels));\n      return {\n        success: true\n      };\n    }\n    promoteUserToGroupAdmin(userId, groupId) {\n      const user = this.getUserById(userId);\n      const group = this.getGroupById(groupId);\n      if (!user) return {\n        success: false,\n        error: 'User not found'\n      };\n      if (!group) return {\n        success: false,\n        error: 'Group not found'\n      };\n      // Add groupAdmin role if not already present\n      if (!user.roles.includes('groupAdmin')) {\n        user.roles.push('groupAdmin');\n      }\n      // Add to group admins if not already\n      if (!group.adminUserIds.includes(userId)) {\n        group.adminUserIds.push(userId);\n      }\n      // Add to user's groups if not already\n      if (!user.groups.includes(groupId)) {\n        user.groups.push(groupId);\n      }\n      this.updateUser(user);\n      this.updateGroup(group);\n      return {\n        success: true\n      };\n    }\n    // Group management\n    getAllGroups() {\n      return JSON.parse(localStorage.getItem(this.GROUPS_KEY) || '[]');\n    }\n    getGroupById(id) {\n      const groups = this.getAllGroups();\n      return groups.find(g => g.id === id) || null;\n    }\n    getGroupsForUser(userId) {\n      const groups = this.getAllGroups();\n      return groups.filter(g => g.memberUserIds.includes(userId));\n    }\n    createGroup(name, ownerUserId) {\n      const groups = this.getAllGroups();\n      // Check for duplicate name\n      if (groups.find(g => g.name === name)) {\n        return {\n          success: false,\n          error: 'Group name already exists'\n        };\n      }\n      const newGroup = {\n        id: Date.now().toString(),\n        name,\n        ownerUserId,\n        adminUserIds: [ownerUserId],\n        memberUserIds: [ownerUserId],\n        channelIds: []\n      };\n      groups.push(newGroup);\n      localStorage.setItem(this.GROUPS_KEY, JSON.stringify(groups));\n      // Add group to user's groups\n      const user = this.getUserById(ownerUserId);\n      if (user) {\n        user.groups.push(newGroup.id);\n        this.updateUser(user);\n      }\n      return {\n        success: true,\n        group: newGroup\n      };\n    }\n    updateGroup(group) {\n      const groups = this.getAllGroups();\n      const index = groups.findIndex(g => g.id === group.id);\n      if (index !== -1) {\n        groups[index] = group;\n        localStorage.setItem(this.GROUPS_KEY, JSON.stringify(groups));\n      }\n    }\n    addMemberToGroup(groupId, userId) {\n      const group = this.getGroupById(groupId);\n      const user = this.getUserById(userId);\n      if (!group) return {\n        success: false,\n        error: 'Group not found'\n      };\n      if (!user) return {\n        success: false,\n        error: 'User not found'\n      };\n      if (group.memberUserIds.includes(userId)) {\n        return {\n          success: false,\n          error: 'User is already a member'\n        };\n      }\n      group.memberUserIds.push(userId);\n      user.groups.push(groupId);\n      this.updateGroup(group);\n      this.updateUser(user);\n      return {\n        success: true\n      };\n    }\n    removeMemberFromGroup(groupId, userId) {\n      const group = this.getGroupById(groupId);\n      const user = this.getUserById(userId);\n      if (!group) return {\n        success: false,\n        error: 'Group not found'\n      };\n      if (!user) return {\n        success: false,\n        error: 'User not found'\n      };\n      group.memberUserIds = group.memberUserIds.filter(id => id !== userId);\n      group.adminUserIds = group.adminUserIds.filter(id => id !== userId);\n      user.groups = user.groups.filter(id => id !== groupId);\n      this.updateGroup(group);\n      this.updateUser(user);\n      return {\n        success: true\n      };\n    }\n    // Channel management\n    getAllChannels() {\n      return JSON.parse(localStorage.getItem(this.CHANNELS_KEY) || '[]');\n    }\n    getChannelById(id) {\n      const channels = this.getAllChannels();\n      return channels.find(c => c.id === id) || null;\n    }\n    getChannelsForGroup(groupId) {\n      const channels = this.getAllChannels();\n      return channels.filter(c => c.groupId === groupId);\n    }\n    createChannel(groupId, name) {\n      const channels = this.getAllChannels();\n      const group = this.getGroupById(groupId);\n      if (!group) return {\n        success: false,\n        error: 'Group not found'\n      };\n      // Check for duplicate name within the group\n      const existingChannel = channels.find(c => c.groupId === groupId && c.name === name);\n      if (existingChannel) {\n        return {\n          success: false,\n          error: 'Channel name already exists in this group'\n        };\n      }\n      const newChannel = {\n        id: Date.now().toString(),\n        groupId,\n        name,\n        bannedUserIds: []\n      };\n      channels.push(newChannel);\n      group.channelIds.push(newChannel.id);\n      localStorage.setItem(this.CHANNELS_KEY, JSON.stringify(channels));\n      this.updateGroup(group);\n      return {\n        success: true,\n        channel: newChannel\n      };\n    }\n    banUserFromChannel(channelId, userId) {\n      const channel = this.getChannelById(channelId);\n      if (!channel) return {\n        success: false,\n        error: 'Channel not found'\n      };\n      if (channel.bannedUserIds.includes(userId)) {\n        return {\n          success: false,\n          error: 'User is already banned from this channel'\n        };\n      }\n      channel.bannedUserIds.push(userId);\n      const channels = this.getAllChannels();\n      const index = channels.findIndex(c => c.id === channelId);\n      if (index !== -1) {\n        channels[index] = channel;\n        localStorage.setItem(this.CHANNELS_KEY, JSON.stringify(channels));\n      }\n      return {\n        success: true\n      };\n    }\n    isUserBannedFromChannel(channelId, userId) {\n      const channel = this.getChannelById(channelId);\n      return channel ? channel.bannedUserIds.includes(userId) : false;\n    }\n    static {\n      this.ɵfac = function DataService_Factory(t) {\n        return new (t || DataService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: DataService,\n        factory: DataService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return DataService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}